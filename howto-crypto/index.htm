<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<!--
This program is free software. It comes without any warranty, to
the extent permitted by applicable law. You can redistribute it
and/or modify it under the terms of the Do What The Fuck You Want
To Public License, Version 2, as published by Sam Hocevar and
reproduced below.

DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
Version 2, December 2004

Copyright (C) 2004 Sam Hocevar <sam@hocevar.net>

        Everyone is permitted to copy and distribute verbatim or modified
        copies of this license document, and changing it is allowed as long
        as the name is changed.

DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

        0. You just DO WHAT THE FUCK YOU WANT TO.
-->

<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<title>Crypto-HowTo</title>
		<link rel="icon" href="../static/favicon.ico" type="image/x-icon" />
		<link rel="shortcut icon" href="../static/favicon.ico" type="image/x-icon" />
		<link rel="stylesheet" type="text/css" href="../static/piracy.css" />
		<meta name="robots" content="noindex,nofollow" />
		<meta http-equiv="content-type" content="text/html;charset=utf-8" />
		<!-- Background pattern provided by subtlepatterns.com -->
	</head>
	<body>
		<div id="center-wrap">
			<div id="content-wrap">
				<div id="content-title">
					<h1>Lustige Cryptodinge mit GPG</h1>
					<h2>Eine Zusammenfassung</h2>
				</div>
				<div id="content-main">
					<div>
						<h2>Wieso verschl&uuml;sseln?</h2>
						<div class="section-padding">
							Weil mans kann? Naja, nicht nur deswegen.
							Der Umgang mit Kryptographie - insbesondere asymmetrischer
							Kryptographie - will gelernt sein, es kann immer mal passieren,
							dass es aus irgendwelchen Gr&uuml;nden n&ouml;tig wird,
							Informationen &uuml;ber einen gesicherten Kanal auszutauschen -
							seien es Passw&ouml;rter, geheime Regierungsunterlagen oder Nacktbilder.
						</div>
					</div>

					<div>
						<h2>Wie verschl&uuml;sseln?</h2>
						<p class="annotation">Dieser Abschnitt erz&auml;hlt nur ein paar Krypto-Hintergr&uuml;nde und kann prinzipiell &uuml;bersprungen werden.</span>	
						<div class="section-padding">
							Grunds&auml;tzlich unterscheidet man 2 Typen der Kryptographie:
							<ul>
								<li>
									<h3>Symmetrische Kryptographie</h3>
									Ver- und Entschl&uuml;sselung benutzen den selben Schl&uuml;ssel, dieser muss
									also sowohl dem Sender als auch dem Empf&auml;nger vorher bekannt sein und
									in irgendeiner Form ausgetauscht werden - auch &uuml;ber einen m&ouml;glichst
									sicheren Kanal.
									Vorteile sind wohl die einfachere Umsetzung und Implementierung sowie
									&quot;beweisbarere&quot; Sicherheit und bessere Performance.
								</li>
								<li>	
									<h3>Asymmetrische (aka Public-Key) Kryptographie</h3>
									Der f&uuml;r &quot;dynamischere&quot; Kommunikation interessantere Teil (und auch der
									um den sich dieses Dokument haupts&auml;chlich dreht).
									Hierbei existieren f&uuml;r einen Schl&uuml;ssel zwei Teile, n&auml;mlich ein 
									privater (geheimer) Teil, der (im besten Fall) nur dem Besitzer bekannt ist und
									ein &ouml;ffentlicher Teil, der jedem bekannt sein darf - und je nach System
									auch m&ouml;glichst weit verbreitet werden soll.
									Algorithmen f&uuml;r asymmetrische Krypto sind eher komplex und langsam,
									daher nutzen sie viele Protokolle um zu Beginn einen gemeinsamen Schl&uuml;ssel
									auszutauschen, mit welchem dann die folgende Kommunikation symmetrisch verschl&uuml;sselt
									wird.
								</li>
							</ul>
						</div>
					</div>

					<div>
						<h2>Welche Tools brauche ich?</h2>
						<div class="section-padding">
							Hier unterscheiden sich die beiden grossen Betriebssysteme etwas.
							Der Standard f&uuml;r Kommunikation mit asymmetrischer Kryptographie ist der von 
							<a href="http://en.wikipedia.org/wiki/Phil_Zimmermann">Phil Zimmerman</a>
							entwickelte <a href="http://www.ietf.org/rfc/rfc4880.txt">OpenPGP-Standard</a> 
							und seine Implementationen <a href="http://pgp.com/">PGP</a> (das &quot;Original&quot;, 
							gekauft von Symantec) und <a href="https://www.gnupg.org/">GnuPG</a> (Quelloffene, 
							kostenlose Software (FOSS)).

							<ul>
								<li>
									<h3>Linux</h3>
									Die meisten Distributionen haben GnuPG in ihren Paketarchiven;
									am bequemsten ist es daher, den Paketmanager der Wahl dazu
									zu bewegen, GnuPG zu installieren.
									F&uuml;r Leute, die sich mit der Kommandozeile wohl f&uuml;hlen,
									reicht hierbei die Versionsreihe 1.x vollkommen aus. 
									Diese ist kleiner und hat weniger Abh&auml;ngigkeiten.
									F&uuml;r nicht so text-feste Anwender empfiehlt sich die Versionsreihe
									2.x, die sich mehr in die grafische Umgebung einf&uuml;gt (besonders
									bei der Passworteingabe).
	
									<p>
										Beispiel Debian:<br/>
										<code>
											apt-get install gnupg
										</code><br/>
										bzw<br/>
										<code>
											apt-get install gnupg2
										</code>
									</p>
								</li>

								<li>
									<h3>Windows</h3>
									Man k&ouml;nnte sich nat&uuml;rlich die &quot;Originalversion&quot; von
									PGP kaufen, aber hey, wer will schon Geld ausgeben? ;)
									Es gibt einen Windows-Port von GnuPG (gesponsert/betreut vom BSI - nicht sicher
									was man davon halten soll...), welches sich aber nur unter Schmerzen davon 
									&uuml;berzeugen l&auml;sst, sein Interface auf Englisch auszugeben - wer allerdings 
									gerne deutsche Oberfl&auml;chen hat, d&uuml;rfte hier gl&uuml;cklich werden.
									Der Installer vom BSI zieht auch die Windows-Version von
									<a href="http://www.kde.org/applications/utilities/kleopatra/">Kleopatra</a> 
									(einen grafischen Schl&uuml;sselmanager aus dem KDE-Projekt)
									mit nach, der einige Techniken die in diesem Dokument sp&auml;ter beschrieben werden
									(zb. Offline-Masterkeys) nicht oder nur teilweise unterst&uuml;tzt.
									Es w&auml;re daher wohl (auch unter Sicherheitsaspekten) eine gute Idee,
									zumindest die Key-Erzeugung mit einem (Live-)Linux-System vorzunehmen.
									<br/><br/>
									Es ist wohl auch m&ouml;glich GnuPG unter Cygwin zu bauen, wenn man
									sich diesen Spass g&ouml;nnen will.
								</li>
							</ul>
						</div>
					</div>
					
					<div>
						<h2>Was ist ein GPG-Key(pair)?</h2>
						<div class="section-padding">
							Eine der Grundeinheiten des GPG-&Ouml;kosystems ist der GPG-Key (bzw das
							GPG-Keypair, bestehend aus einem privaten und einem &ouml;ffentlichen Teil), 
							der lose gesagt die Repr&auml;sentation eines Benutzers (bzw. eines Individuums) 
							darstellt.

							<p>
								Der Begriff des &quot;Key&quot; ist im PGP-Jargon doppeldeutig: Er kann sowohl
								eine komplette Identit&auml;t meinen, als auch einen spezifischen kryptographischen
								Schl&uuml;ssel. Ein &quot;Identit&auml;tsschl&uuml;ssel&quot; kann mehrere
								&quot;Kryptographieschl&uuml;ssel&quot;, auch mit unterschiedlichen Anwendungsbereichen
								(Signieren, Verschl&uuml;sseln) und Algorithmen (RSA, DSA, ElGamal) besitzen.
								Jeder Kryptographie-Schl&uuml;ssel hat einen eigenen &ouml;ffentlichen sowie privaten Teil,
								Der &ouml;ffentliche Teil des Identit&auml;tsschl&uuml;ssel bezeichnet dann alle
								&ouml;ffentlichen Teile der in ihm enthaltenen Kryptographieschl&uuml;ssel, analog
								mit dem privaten Teil.<br/>
								Der Fingerprint des Haupt-Kryptographieschl&uuml;ssels wird meist stellvertretend
								als Identifikation des Identit&auml;tsschl&uuml;ssels verwendet.
							</p>

							Ein GPG-Key enth&auml;lt mehrere Untereinheiten:

							<ul>
								<li>
									<h3>Hauptschl&uuml;ssel</h3>
									Der prim&auml;re Schl&uuml;ssel am Keypair (meist ein Signatur-Key) wird oft
									als Haupt-Identifikationsmerkmal fuer den gesamten Schl&uuml;ssel verwendet.
								</li>
								<li>
									<h3>User-IDs (UIDs)</h3>
									Ein Key kann viele verschiedene Identit&auml;ten eines einzelnen Benutzers
									enthalten. Eine UID besteht aus einem Namen, einer Emailadresse und einem Kommentar.
									Nur das Namensfeld ist zwingend erforderlich, die anderen beiden sind optional.

									<p>
										Im Normalfall hat ein Key eine UID f&uuml;r jede Emailadresse, auf der der Benutzer
										verschl&uuml;sselte/signierte Kommunikation senden oder empfangen m&ouml;chte.
										UIDs werden besonders im Zusammenhang mit dem Web of Trust zu wichtigen Merkmalen
										eines Keys.
									</p>
								
									<p>
										UIDs haben jedoch keinen kryptographischen Einfluss auf den Schl&uuml;ssel,
										sondern gelten nur als Identifikationsm&ouml;glichkeit (bedeutet: Es wird nicht
										an eine bestimmte UID verschl&uuml;sselt, sondern an einen bestimmten Krypto-Key).
									</p>

									<p>
										Der Besitzer eines Keys kann diesem w&auml;hrend seiner Lebenszeit unbegrenzt
										viele UIDs hinzuf&uuml;gen und diese auch wieder &quot;zur&uuml;ckrufen&quot; (revoken).
										Es ist zwar m&ouml;glich eine UID von einem Key zu l&ouml;schen, jedoch
										werden Keys normalerweise additiv importiert - sprich, hat ein anderer User
										den &ouml;ffentlichen Schl&uuml;ssel in einer Version, in der die gel&ouml;schte UID
										noch existiert, so wird diese beim Import der neuen Version nicht gel&ouml;scht,
										sondern existiert weiter.
									</p>
								</li>

								<li>
									<h3>Subkeys</h3>
									Ein Schl&uuml;sselpaar kann beliebig viele &quot;Unterschl&uuml;ssel&quot; besitzen - 
									mit jeweils eigenen Schl&uuml;sselalgorithmen, Ablaufdaten, Schl&uuml;ssell&auml;ngen
									und Fingerprints.
									Trotzdem sind diese Subkeys mathematisch Teil des &uuml;bergeordneten Schl&uuml;ssels.
									Ihre privaten Teile k&ouml;nnen jedoch unabh&auml;ngig von denen des Hauptschl&uuml;ssels 
									exportiert und verwendet werden, wodurch sich einige Verbesserungen in der Benutzbarkeit 
									ergeben.
									<p>
										Genau wie UIDs kann der Besitzer eines Schl&uuml;ssels diesem w&auml;hrend seiner Lebenszeit
										beliebig viele Subkeys hinzuf&uuml;gen und diese auch wieder zur&uuml;ckrufen.
									</p>

									Anders als UIDs sind Subkeys jedoch kryptographisch relevant:
									Sie besitzen einen eigenen eindeutigen Fingerprint und an sie kann speziell verschl&uuml;sselt
									(Encryption-Subkeys) oder mit ihnen signiert (Signing-Subkeys) werden.
								</li>
								<li>
									<h3>Photo IDs</h3>
									Es ist auch m&ouml;glich, kleinere Bilddateien an Schl&uuml;ssel anzuh&auml;ngen.
									Diese k&ouml;nnen bspw. als weiteres Verifikationsmedium f&uuml;r die Identit&auml;t eines 
									Schl&uuml;sselinhabers genutzt werden.
								</li>
							</ul>
						</div>
					</div>

					<div>
						<h2>Vorbereitungen &amp; Notwendigkeiten</h2>
						<p class="annotation">
							Mangels Erfahrung mit Alternativen werden wir uns hier auf den Umgang mit GnuPG 
							unter Linux-Systemen beschr&auml;nken. Ein bisschen Erfahrung mit der Kommandozeile 
							muss leider auch vorausgesetzt werden, obwohl wir unser bestes tun werden, die 
							Befehle zu erkl&auml;ren.
						</p>
						
						<div class="section-padding">
							F&uuml;r die Erstellung eines guten&trade; Schl&uuml;sselpaares empfiehlt es
							sich, eine &quot;sichere&quot; Maschine zu benutzen - also ein System,
							bei dem man davon ausgehen kann, dass es bisher &quot;&uuml;berwachungsfrei&quot; 
							ist und welches m&ouml;glichst wenig Angriffsfl&auml;che bietet.

							<p>
								Hierzu bieten sich einige M&ouml;glichkeiten:
								<ul>
									<li>
										<h3>Livesysteme</h3>
										Es gibt einige Linux-Distributionen (oder auch BSD, falls jemand das lieber ist),
										die Live-Medien anbieten (bspw. <a href="https://tails.boum.org/">Tails</a>, 
										<a href="http://grml.org/">grml</a>) - also bootbare USB-Sticks oder CDs
										die schon alles n&ouml;tige f&uuml;r GPG an Bord haben (und im Idealfall
										auch nicht mehr als das).
									</li>
									<li>
										<h3>Ein Offline-/Airgapped-System</h3>
										Bei dieser Methode verwendet man einen Computer (am sinnvollsten einen Laptop)
										nur f&uuml;r diesen Zweck. Er wird einmal mit einem minimalen System (von einem
										vertrauensw&uuml;rdigen Medium) installiert und darf niemals eine Internetverbindung
										haben - daher der Name &quot;Airgap&quot;.
									</li>
								</ul>
								Generell empfiehlt es sich, auf dem System der Wahl m&ouml;glichst
								wenige Prozesse aktiv zu haben (bspw. nur Textsystem), w&auml;hrend der Erzeugung keine
								physische Netzwerkverbindung zu haben (Kabel ziehen!) und die
								sensitiven Daten bspw. auf einem verschl&uuml;sselten USB-Stick (mit einer Partition, die nie
								an &quot;unsicheren&quot; Systemen gemountet wird und einer, die dazu dient, Daten auf
								&quot;potentiell sichere&quot; Systeme zu &uuml;bertragen) zu speichern.
							</p>

							<p>
								Um ein solches sicheres Speichermedium zu erzeugen, empfiehlt sich die Verwendung eines neuen
								USB-Sticks aus einer vertrauensw&uuml;rdigen Quelle (bspw. ein zuf&auml;llig ausgew&auml;hlter
								Elektronikmarkt). Um zus&auml;tzlichen Schutz zum Beispiel bei Verlust zu schaffen, sollte mindestens
								eine Partition auf diesem Medium verschl&uuml;sselt sein (zum Beispiel mit <a href="https://gitlab.com/cryptsetup/cryptsetup">LUKS</a>).
								M&ouml;glicherweise kann die Einrichtung einer unverschluesselten Partition zum Transfer von bspw.
								&Ouml;ffentlichen Schl&uuml;sseln sinnvoll sein, daf&uuml;r kann aber auch einfach ein weiterer
								USB-Stick verwendet werden.
							</p>

							<p>
								Jetzt noch einige Worte dazu, wie GPG Schl&uuml;ssel auf
								der Platte verwaltet:<br/>
								Von Haus aus benutzt GPG das Verzeichnis <code>.gnupg/</code> 
								im Home-Ordner des jeweiligen Benutzers, um alle Daten zu
								speichern. Schl&uuml;ssel werden dabei in sogenannten
								&quot;Keyrings&quot; organisiert, die man sich als Container
								f&uuml;r mehrere Schl&uuml;ssel vorstellen kann.
							       	Folgende Dateien finden sich im Normalfall
								mindestens in ~/.gnupg/:
								<ul>
									<li>
										<strong>secring.gpg</strong> - 
										Enth&auml;lt die privaten Teile von Schl&uuml;sseln, 
										wo sie bekannt sind.
									</li>
									<li>
										<strong>pubring.gpg</strong> - 
										Enth&auml;lt alle &ouml;ffentlichen Schl&uuml;ssel.
									</li>
									<li>
										<strong>trustdb.gpg</strong> - 
										Enth&auml;lt Informationen dar&uuml;ber, zu welchem
										Grad bestimmten Schl&uuml;sseln vertraut wird.
									</li>
								</ul>

								<code>pubring.gpg</code> und <code>secring.gpg</code> werden
								von GnuPG standardm&auml;ssig als Keyrings verwendet.
								Nat&uuml;rlich ist es auf einem Livesystem eher ungewollt,
								diese Dateien im Homeverzeichnis zu haben, daher macht es Sinn
								sich bspw. einen verschl&uuml;sselten USB-Stick zu bauen und
								das Master-Keypair dort zu speichern.
								Dazu legen wir auf dem sicheren Speichermedium einen Ordner names
								<code>gpg_home</code> an, welchen wir sp&auml;ter an GPG als tempor&auml;res
								Homeverzeichnis &uuml;bergeben.
							</p>
							
							<p>
								Innerhalb dieses Homeverzeichnisses kann auch die Konfiguration von GPG
								angepasst werden, was uns die sp&auml;tere &Uuml;bergabe einiger Kommandozeilenparameter
								erspart.
								<br />
								Hierzu legt man darin eine Datei namens <code>gpg.conf</code> an, in welcher
								dann zeilenweise Optionen angegeben werden k&ouml;nnen.
							</p>
							
							<p>
								Beispielhaft seien hierbei folgende Optionen genannt
								<ul>
									<li>
										<p>
											<code>no-emit-version</code>
										</p>
										Keine Versions-/Programmkennzeichen in Ausgabetexte einbetten
									</li>
									<li>
										<p>
											<code>default-preference-list SHA512 SHA384 SHA256 SHA224 AES256 AES192 AES CAST5 ZLIB BZIP2 ZIP Uncompressed</code>
										</p>
										Erspart uns das Setzen der Algorithmenpr&auml;ferenzliste &uuml;ber die Kommandozeile
									</li>
									<li>
										<p>
											<code>ask-cert-level</code>
										</p>
										Beim signieren eines Schl&uuml;ssels nach der Vertrauensstufe fragen
									</li>
								</ul>
							</p>
						</div>
						
						
					</div>

					<div>
						<h2>Wie erzeuge ich mein Keypair?</h2>
						<p class="annotation">
							Mangels Erfahrung mit Alternativen werden wir uns hier auf den Umgang mit GnuPG 
							unter Linux-Systemen beschr&auml;nken. Ein bisschen Erfahrung mit der Kommandozeile 
							muss leider auch vorausgesetzt werden, obwohl wir unser bestes tun werden, die 
							Befehle zu erkl&auml;ren.
						</p>
						<div class="section-padding">
							Diese Anleitung versucht, ein m&ouml;glichst sicheres Schema
							f&uuml;r die Benutzung einer Identit&auml;t auch auf mehreren
							Ger&auml;ten zu beschreiben. Ein einfacher Schl&uuml;ssel ohne weitere
							Sicherheitsvorkehrungen kann mit dem Befehl
							<code>
								gpg <span title="Starte Key-Erzeugungs-Assistent">--gen-key</span>
							</code>
							interaktiv erzeugt werden.

							<p>
								Wir werden in dieser Anleitung ein Keypair mit mehreren
								Subkeys (siehe oben) erzeugen - in unserem Fall mit einem
								Encryption-Subkey (wer sich der Implikationen bewusst ist
								kann auch gerne mehrere Encryption-Subkeys erzeugen) sowie
								einem Signing-Subkey pro Ger&auml;t auf dem der Schl&uuml;ssel
								verwendet werden soll.
								<br/><br/>

								Die einzelnen Ger&auml;te sollen dabei auch nur die geheimen
								Teile ihrer jeweiligen Subkeys besitzen, sodass selbst
								wenn eines der Ger&auml;te kompromittiert (verloren, &uuml;berwacht,
								gel&ouml;scht) wird, der Besitzer mit dem Master-Keypair problemlos 
								nur diesen einzelnen Subkey revoken kann und dabei nicht automatisch
								das gesamte Keypair verliert oder die Sicherheit der anderen
								Ger&auml;te aufs Spiel setzt.
							</p>

							<p>
								Damit kommen wir auch schon zum Hauptteil. Die nachfolgenden
								Schritte sollten nacheinander auf dem vorher erw&auml;hnten
								sicheren System (mit gemountetem sicheren Storage-Medium) ausgef&uuml;hrt 
								werden.
								<ol>
									<li>
										<h3>GNUPGHOME setzen</h3>
										Damit unsere Schl&uuml;ssel nicht auf der Platte oder im
										tempor&auml;ren Homeverzeichnis unseres Livesystems landen,
										setzen wir mit <br/>
										<code>user@box:~$ 
											<span title="Setze Umgebungsvariable">export</span>
											GNUPGHOME=/media/meinSicheresMedium/gpg_home</code>	
										<br/>
										eine Umgebungsvariable, die GPG anweist, seine Dateien auf unserem sicheren 
										Medium zu speichern. Der Ordner sollte die Zugriffsmaske 700
										(Besitzer: lesen, schreiben, ausf&uuml;hren; Gruppe: keine; Alle: keine)
										besitzen, ansonsten kann es sein dass GPG bei manchen Befehlen wegen
										&quot;unsicherer Zugriffsrechte&quot; den Dienst verweigert.
									</li>
									<li>
										<h3>Master-Keypair generieren</h3>
										Mit dem Befehl<br/>
										<code>user@box:~$ gpg 
											<span title="Key-Erzeugungs-Assistent starten">--gen-key</span>
										</code>	
										<br/>
										starten wir den Assistenten zur Schl&uuml;sselerzeugung.
										GPG f&uuml;hrt uns nun durch einige Abfragen, die
										den neuen Key betreffen.
										Wir m&ouml;chten einen Schl&uuml;ssel, der sowohl
										signieren als auch verschl&uuml;sseln kann.
										In unserem Fall kann man diesen sogar unbegrenzt
										gelten lassen, da wir uns gleich noch einige
										Rettungsseile basteln werden und der Master-Key relativ
										sicher sein wird.
										Als erste UID reicht im Zweifelsfall auch der Name
										ohne Email-Adresse oder Kommentar (wir werden sp&auml;ter
										noch Gelegenheit haben, andere hinzuzuf&uuml;gen).
										Als Passphrase sollten wir hier eine m&ouml;glichst
										komplexe Zeichenfolge aussuchen. Die Ger&auml;tespezifischen
										Schl&uuml;ssel werden eigene Passphrasen bekommen.
									</li>
									<li>
										<h3>Pr&auml;ferierte Algorithmen &amp; weitere UIDs</h3>
										Jetzt werden wir den gerade erstellten Schl&uuml;ssel bearbeiten,
										um einige Einstellungen vorzunehmen und weitere UIDs
										hinzuzuf&uuml;gen.<br/>
										<code>user@box:~$ gpg 
											<span title="Starte Key-Bearbeitungs-Assistent">--edit-key</span>
											<span title="Zu bearbeitender Key">&lt;identifier&gt;</span>
										</code><br/>
										&lt;identifier&gt; kann hierbei sein:
										<ul>
											<li>(Teil-)Fingerprint</li>
											<li>Teile der UID</li>
										</ul>
										GPG pr&auml;sentiert uns nun sein interaktives Interface.
										Wir f&uuml;hren darin folgenden Befehl aus, um die bevorzugten
										Algorithmen etwas zu st&auml;rken (dieser Schritt kann ausgelassen werden, falls
										die Pr&auml;ferenzen bereits wie oben in <code>gpg.conf</code> gesetzt wurde):<br/>
										<code>gpg&gt; 
											<span title="Setze Algorithmenpr&auml;ferenzen">setpref</span>
											SHA512 SHA384 SHA256 SHA224 AES256 AES192 AES CAST5 ZLIB BZIP2 ZIP Uncompressed</code>
										<br/>
										GPG fragt uns nach der Passphrase, welche wir uns nat&uuml;rlich
										mittlerweile auswendig gemerkt haben ;).

										Danach k&ouml;nnen auf der GPG-Kommandozeile mit<br/>
										<code>gpg&gt; adduid</code><br/>
										weitere UIDs interaktiv hinzugef&uuml;gt werden.
										Abschliessend speichern wir unsere &Auml;nderungen mit einem<br/>
										<code>gpg&gt; save</code>

									</li>
									<li>
										<h3>Subkeys hinzuf&uuml;gen</h3>
										Wir beginnen wieder mit<br/>
										<code>user@box:~$ gpg --edit-key &lt;identifier&gt;</code><br/>
										unseren Key zu bearbeiten. Diesmal starten wir mit<br/>
										<code>gpg&gt; addkey</code><br/>
										den Assistent f&uuml;r das hinzuf&uuml;gen eines Subkeys. Wir entsperren
										hierf&uuml;r unseren Schl&uuml;ssel wie gehabt mit der Passphrase und
										w&auml;hlen dann den Typ, den unser neuer Subkey haben soll - in
										unserem Fall dann ein &quot;Sign only&quot;-Key. Es ist auch m&ouml;glich,
										einen Encryption-Subkey pro Ger&auml;t zu erstellen - nur muss dies demjenigen,
										der an den Besitzer verschl&uuml;sselt, kommuniziert werden. Dateien, die an
										einen bestimmten Subkey verschl&uuml;sselt sind, k&ouml;nnen auch nur mit
										dessen privaten Teil entschl&uuml;sselt werden.<br/>
										Den Subkeys geben wir in unserem Fall am besten eine Lebenszeit von
										2 Jahren - nach denen dem Master-Key dann problemlos neue hinzugef&uuml;gt und
										diese dann die alten auf den Ger&auml;ten ersetzen.<br/>
										Haben wir alle unsere Subkeys erzeugt, speichern wir unsere &Auml;nderungen
										mit einem<br/>
										<code>gpg&gt; save</code>
									</li>
									<li>
										<h3>Revocation Certificate generieren</h3>
										Um das komplette Master-Keypair im Notfall (bspw. geheime Teile komplett verloren) 
										zur&uuml;ckrufen zu k&ouml;nnen, erzeugen wir jetzt ein sogenanntes 
										&quot;Revocation Certificate&quot; mit<br/>
										<code>user@box:~$ gpg --gen-revoke &lt;identifier&gt; &gt; /media/meinSicheresMedium/master-pair.revcert</code><br/>
										Die entstandene Datei sollten wir wenn irgendwie m&ouml;glich auch auf einem
										sicheren Drucker drucken (ist nicht &uuml;berm&auml;ssig gross) und danach irgendwo
										sicher aufbewahren. Im &auml;ussersten Notfall k&ouml;nnen wir das Revocation
										Certificate dann abtippen, importieren und an die Keyserver senden, um unser
										Master-Keypair als ung&uuml;ltig zu markieren.
									</li>
									<li>
										<h3>Komplettes Master-Keypair exportieren</h3>
										Als n&auml;chstes werden wir das komplette Master-Keypair, inklusive
										der Subkey-Secrets exportieren.<br/>
										<code>
											user@box:~$ gpg 
												<span title="Exportieren eines Schl&uuml;ssels">--export</span>
												<span title="Nutze textbasiertes Format">--armor</span>
												<span title="Unterdr&uuml;cke die Versionsangabe">--no-emit-version</span> 
												<span title="Zu exportierender Key">&lt;identifier&gt;</span> 
												<span title="nach Datei schreiben">&gt;</span> 
												<span title="Ausgabedatei">/media/unsichererTeil/mein-key.asc</span>
												<br/>
											user@box:~$ gpg --export-secret-keys --armor &lt;identifier&gt; &gt; /media/meinSicheresMedium/master.secret-key
										</code>
										<br/>
										Die resultierende .secret-key Datei ist der wichtigste Teil der ganzen &Uuml;bung.
										Bekommt ein Angreifer sie in die Hand, haben wir verloren (bis auf die Passphrase,
										allerdings ist das je nach Angreifer eine minimale Barriere) und die einzige
										Chance ist das Revocation Certificate.<br/>
										Die .asc Datei ist unser &ouml;ffentlicher Schl&uuml;ssel, weswegen wir ihn auch
										auf den &quot;unsicheren&quot; Teil unseres Speichermediums exportiert haben.
										Eine Kopie im sicheren Teil vorzuhalten schadet jedoch nicht.
									</li>
									<li>
										<h3>Subkeys einzeln exportieren &amp; Passphrasen anpassen</h3>
										In diesem Schritt werden wir nun die Dateien erzeugen, die wir auf die einzelnen
										Ger&auml;te verteilen werden. Hierzu m&uuml;ssen wir uns entscheiden,
										welche Subkeys auf welchem Ger&auml;t verf&uuml;gbar sein sollen.
										Um Dateien/Texte zu signieren und verschl&uuml;sselte Dateien zu versenden,
										gen&uuml;gt ein Signing-Subkey.
										Soll das Ger&auml;t auch verschl&uuml;sselte Dateien empfangen und entschl&uuml;sseln
										sollen, so wird ein Encryption-Subkey ben&ouml;tigt. 
										<p>
											Hierbei m&uuml;ssen wir beachten, dass verschl&uuml;sselte Dateien immer nur 
											mit dem Subkey entschl&uuml;sselt werden k&ouml;nnen, an den sie auch 
											verschl&uuml;sselt wurden.
											Es besteht zwar die M&ouml;glichkeit, an mehrere Subkeys zu verschl&uuml;sseln,
											jedoch muss dies dem Sender kommuniziert werden (und wird nicht von jeder 
											Software unterst&uuml;tzt). Am einfachsten ist es daher, einen 
											Encryption-Subkey am Master-Keypair zu haben, und diesen nur auf Ger&auml;ten, 
											denen zumindest grundlegend vertraut wird, zu verwenden.
										</p>
										Um die Passphrase anzupassen, begeben wir uns wieder in den Bearbeitungsmodus:<br/>
										<code>user@box:~$ gpg --edit-key &lt;identifier&gt;</code><br/>
										und starten mit<br/>
										<code>gpg&gt; passwd</code><br/>
										den Assistenten zum &auml;ndern der Passphrase und &auml;ndern diese in
										unsere &quot;Ger&auml;tepassphrase&quot;. 
										
										Wir speichern wie gewohnt unsere &Auml;nderungen mit<br/>
										<code>gpg&gt; save</code><br/>

										Danach exportieren wir mit<br/>
										<code>user@box:~$ gpg --armor --export-secret-subkeys &lt;subfp1&gt;! &lt;subfp2&gt;! &gt /media/meinSicheresMedium/geraetN.subkey-secrets</code><br/>
										nacheinander die Subkeys f&uuml;r die einzelnen Ger&auml;te.
										<code>subfpN</code> bezeichnet hierbei die Fingerprints der Subkeys, die exportiert
										werden sollen. Die Ausrufezeichen nach den Fingerprints sind wichtig (sonst exportiert
										GPG aus unerfindlichen Gr&uuml;nden alle Subkey-Secrets)!<br/>
										Nat&uuml;rlich k&ouml;nnen wir auch pro Ger&auml;t eine eigene Passphrase festlegen - 
										dazu m&uuml;ssen wir nur vor jedem Export die Passphrase &auml;ndern.
									</li>
									<li>
										<h3>Komplettes Master-Keypair wieder in secring.gpg importieren</h3>
										Statt uns die M&uuml;he zu machen, die Passphrase des Master-Keypairs wieder
										zur&uuml;ck zu &auml;ndern, l&ouml;schen wir es einfach mit dem Befehl<br/>
										<code>user@box:~$ gpg --delete-secret-key &lt;identifier&gt;</code><br/>
										vom Keyring und importieren es danach mit<br/>
										<code>user@box:~$ gpg --import /media/meinSicheresMedium/master.secret-key</code><br/>
										komplett neu.
									</li>
									<li>
										<h3>Ger&auml;te-Keypairs importieren</h3>
										Auf den jeweiligen Ger&auml;ten k&ouml;nnen jetzt die .subkey-secret Dateien
										importiert werden.
										Die Ausgabe des Befehls<br/>
										<code>user@box:~$ gpg --list-secret-keys</code><br/>
										sollte dabei jetzt <code>sec#</code> am Hauptschl&uuml;ssel anzeigen,
										was bedeutet dass der geheime Schl&uuml;ssel f&uuml;r das Master-Pair
										nicht vorhanden ist - wohl aber der f&uuml;r bestimmte Subkeys.
									</li>
								</ol>
								
								Damit haben wir uns ein ziemlich gutes&trade; Keypair gebaut!
								Wenn wir den &ouml;ffentlichen Teil des Master-Keys jetzt auf einer
								&quot;unsicheren&quot; Maschine mit <br/>
								<code>user@box:~$ gpg --import /media/unsichererTeil/mein-key.asc</code> <br/>
								wieder importieren und mit<br/>
								<code>user@box:~$ gpg --send-keys &lt;fingerprint&gt;</code><br/>
								an einen Keyserver schicken, k&ouml;nnen uns auch andere Menschen
								finden. Alternativ (oder auch zus&auml;tzlich) kann man nat&uuml;rlich 
								den &ouml;ffentlichen Teil auch auf seiner Homepage zum Download anbieten.
							</p>
						</div>
					</div>

					<div>
						<h2>Wie verschl&uuml;ssele/entschl&uuml;ssele/signiere ich?</h2>
						<div class="section-padding">
							Damit kommen wir jetzt zur konkreten Anwendung von GnuPG - also dem
							eigentlich interessanten Teil ;)

							<p>
								F&uuml;r bestimmte Protokolle/Vorg&auml;nge bei denen GPG eingesetzt werden
								kann, gibt es auch eigene Tools, die die Benutzung einfacher machen - 
								beispielsweise das <a href="https://www.enigmail.net/">Enigmail-Plugin</a> f&uuml;r 
								Thunderbird.<br/>

								Die Benutzung dieser Tools sollte meist entweder selbsterkl&auml;rend sein,
								oder den jeweiligen manpages oder README-Files entnehmen zu sein.<br/>
								Wir werden uns hier wieder auf die Benutzung von GPG mit der Kommandozeile
								unter Linux beschr&auml;nken. Solltest du jedoch Muse haben, einige Abs&auml;tze
								&uuml;ber ein bestimmtes Tool zu schreiben, bist du herzlich Willkommen, diese
								<a href="https://github.com/kitinfo/party-portal/">zu diesem Dokument beizutragen!</a>
							</p>

							<p>
								Sollte es uns eines Tages zu M&uuml;hselig werden, f&uuml;r jede einzelne Aktion
								unseren Key mit unserer Passphrase zu entsperren, lohnt sich ein Blick auf
								<a href="https://www.gnupg.org/documentation/manuals/gnupg/Invoking-GPG_002dAGENT.html">gpg-agent</a>. 
								Der Agent erlaubt uns, unser Keypair einmal zu entsperren, h&auml;lt es danach
								f&uuml;r eine bestimmte Zeit in entsperrter Form vor und erspart uns so etwas Tipparbeit.
							</p>

							<p>
								Die folgenden Vorgehensweisen funktionieren mit den Ger&auml;tesubkeys, die Nutzung
								des Master-Keys ist (ausser wenn an diesen verschl&uuml;sselt wurde) nicht notwendig.
							</p>

							<h3>Signieren &amp; Verifizieren</h3>	
							Um einen kryptographischen &quot;Beweis&quot; anzufertigen, dass wir Urheber eines bestimmten Dokumentes 
							bzw. einer Datei sind und diese Datei auch zwischenzeitlich nicht ver&auml;ndert wurde, k&ouml;nnen 
							wir mit GPG eine Signatur f&uuml;r eine Datei erzeugen. Hierzu ben&ouml;tigen wir einen Signing-Key
							dessen privaten Teil wir besitzen (e.g. unser ger&auml;tespezifischer Signing-Subkey) und f&uuml;hren 
							dann folgenen Befehl aus:<br/>
							<code>user@box:~$ gpg --detach-sign &lt;filename&gt;</code><br/>
							GPG erzeugt nun eine bin&auml;re Signatur und speichert sie in der Datei &lt;filename&gt;.sig.<br/>
							Um eine Signatur einer Datei auch in normalen Texten einbetten zu k&ouml;nnen, ist es meist sinnvoller,
							die Signatur in einem ASCII-basierten Format ausgeben zu lassen. Dies erreichen wir mit<br/>
							<code>user@box:~$ gpg --armor --no-emit-version --detach-sign &lt;filename&gt;</code><br/>
							Dieser Befehl erzeugt die Datei &lt;filename&gt;.asc, welche eine ASCII-Form der Signatur enth&auml;lt.<br/>
							Ist die zu signierende Datei eine Textdatei, so kann die Signatur auch direkt an die Nachricht angeh&auml;ngt
							werden. Dies geschieht mittels<br/>
							<code>user@box:~$ gpg --no-emit-version --clearsign &lt;filename&gt;</code><br/>
							was wiederum die Datei &lt;filename&gt;.asc erzeugt, diesmal aber mit der Originaldatei gefolgt von
							ihrer Signatur.

							<p>
								Soll mit einem anderen Schl&uuml;ssel als mit dem Standardschl&uuml;ssel signiert werden,
								kann dies mit dem Parameter <code>--default-key &lt;fingerprint&gt;</code> eingestellt werden.
							</p>

							Um die Signatur einer Datei zu verifizieren, m&uuml;ssen wir den &ouml;ffentlichen Schl&uuml;ssel des
							Schl&uuml;sselpaares besitzen, mit dem die Datei signiert wurde (beispielweise via Download von einem
							Keyserver). Danach k&ouml;nnen wir mit einem<br/>
							<code>user@box:~$ gpg --verify &lt;filename&gt;.asc &lt;filename&gt;</code><br/>
							&uuml;berpr&uuml;fen, ob die vorhandene Datei derjenigen entspricht, die urspr&uuml;nglich signiert wurde.

							<h3>Verschl&uuml;sseln &amp; Entschl&uuml;sseln</h3>
							Um eine Datei (oder eine Nachricht) an einen bestimmen Empf&auml;nger zu verschl&uuml;sseln,
							ben&ouml;tigen wir dessen Public Key (Tats&auml;chlich ben&ouml;tigen wir dazu nicht einmal ein
							eigenes Keypair). F&uuml;hren wir dann folgenden Befehl aus:<br/>
							<code>
								user@box:~$ gpg --recipient &lt;identifier&gt; --encrypt &lt;filename&gt;
							</code>
							<br/>
							so erzeugt uns GPG die Datei <code>&lt;filename&gt;.gpg</code>, die dann nur von den angegebenen
							Empf&auml;ngern dekodierbar ist.
							Wir k&ouml;nnen auch mehreren Empf&auml;ngern das Entschl&uuml;sseln erm&ouml;glichen, indem
							wir mehrmals <code>--recipient &lt;identifier&gt;</code> angeben (Es kann sinnvoll sein,
							Dateien auch zus&auml;tzlich noch an sich selbst zu verschl&uuml;sseln).
							<p>
								Die hierbei enstehenden Dateien sind Bin&auml;rdateien, und k&ouml;nnen daher nicht ohne
								weiteres bspw. in Emails eingef&uuml;gt werden. Mit dem zus&auml;tzlichen Parameter
								<code>--armor</code> weisen wir GPG an, die verschl&uuml;sselte Datei in einem textbasierten
								Format zu speichern - es wird dann entsprechend die Datei <code>&lt;filename&gt;.asc</code> erzeugt.
								Das kodieren der Bin&auml;rdaten als Text (intern indirekt <a href="https://en.wikipedia.org/wiki/Base64">
								Base64</a>) f&uuml;hrt dazu, dass das Resultat ein wenig mehr Speicher als die bin&auml;r
								kodierte Variante ben&ouml;tigt.
							</p>

							GPG kann auch f&uuml;r symmetrische Verschl&uuml;sselung verwendet werden - hierbei ben&ouml;tigt man dann
							einen bereits vorher ausgetauschten Schl&uuml;ssel, der allen kommunizierenden Parteien bekannt ist - 
							daher der Name "symmetrisch".

							<p>
								Um eine Datei symmetrisch zu verschl&uuml;sseln, setzen wir folgenden Befehl ein: <br/>
								<code>
										user@box:~$ gpg --symmetric &lt;filename&gt;
								</code>
								<br/>
								GPG erfragt dann den zu verwendenden Schl&uuml;ssel von uns, inklusive einer Wiederholung zur Sicherheit.
								Wenn gewollt kann mit der Option <code>--cipher-algo &lt;algorithmus&gt;</code> der zu verwendende symmetrische
								Algorithmus angegeben werden. Die symmetrische Verschl&uuml;sselung azeptiert auch die <code>--armor</code>-Option zur Ausgabe
								von ASCII-kodiertem Text. Auch die Entschl&uuml;sselung der entstehenden Dateien funktioniert mit demselben
								Befehl wie f&uuml;r asymmetrisch verschl&uuml;sselte Dateien.
							</p>

							Die beiden Verschl&uuml;sselungsmodi lassen sich clever kombinieren indem man beispielsweise den Schl&uuml;sselaustausch
							mittels asymmentrischer Verschl&uuml;sselung durchf&uuml;hrt, den eigentlichen Nachrichtenaustausch aber
							mit symmetrischer.

							<h3>Beides auf einmal</h3>
							Die beiden &quot;Betriebsarten&quot; von GPG (Signieren und Verschl&uuml;sseln) lassen sich auch kombinieren - dazu
							m&uuml;ssen wir einfach die jeweils passenden Argumente zusammen angeben ;)
						</div>
					</div>

					<div>
						<h2>Wie funktioniert das Web of Trust?</h2>
						<div class="section-padding">
							Das Web of Trust ist die andere grosse Komponente von GPG, die abgesehen von kryptographischen Aspekten zur Sicherheit des
							Gesamtsystems beitr&auml;gt. Das Web of Trust besteht aus &quot;Bezeugungen&quot; durch individuelle Key-Inhaber, dass ein
							anderer Key-Inhaber derjenige ist, der aus der Key-UID (bspw. durch Name, Foto, etc) hervorgeht. Hierzu wird normalerweise
							die Vorlage eines legalen Ausweisdokumentes verlangt, um die Identit&auml;t gegenpr&uuml;fen zu k&ouml;nnen.
							Danach <em>signiert</em> der Pr&uuml;fende die UIDs am Schl&uuml;ssel des zu pr&uuml;fenden, was eine Bezeugung der Identit&auml;t
							durch diesen Schl&uuml;ssel darstellt. Die entstehenden Signaturen werden dann ver&ouml;ffentlicht, was zum namensgebenden
							Netz an gegenseitigen Vertrauensbezeugungen f&uuml;hrt.
							
							<p>
								Als dritter Teilnehmer n&uuml;tzt mit dieses Netz insofern, als ich diesen Vertrauenspfaden folgen kann, um die Identit&auml;t
								eines Key-Inhabers welchen ich pers&ouml;nlich nicht verifizieren kann (bspw. weil er auf der anderen Seite der Welt wohnt)
								mit relativer Sicherheit festzustellen. M&ouml;chte ich beispielsweise sicherstellen, dass ein Key <em>D</em> auch zu Person
								<em>D</em> geh&ouml;rt (was zum Beispiel zum Beginn einer asymmetrisch verschl&uuml;sselten Kommunikation wichtig ist),
								versuche ich einen Pfad entlang der Schl&uuml;sselsignaturen von mit bis zu meinem Ziel zu finden. Finde ich einen solchen,
								ist die Wahrscheinlichkeit, dass eine dritte Person diesen Schl&uuml;ssel gef&auml;lscht hat, sehr gering. Finde ich
								<em>keinen</em> Pfad, heisst dies aber im Umkehrschluss nicht, dass diese Person nicht die ist, f&uuml;r die sie sich ausgibt.
								Diese Fragestellung ist eines der zentralen Probleme moderner Kommunikation.
							</p>

							Die meisten Teilnehmer am Web of Trust h&auml;ngen an ihren Schl&uuml;ssel eine Information an (bspw. &uuml;ber das Kommentarfeld einer UID),
							welche ihre <em>Signing Policy</em> beschreibt. Dieses Dokument spezifiziert, unter welchen Umst&auml;nden und mit welchen Identit&auml;tsbeweisen
							sie eine Signatur zu einem Key beitragen.
							Da die Identit&auml;t eines Kommunikationspartners (zb. in f&uuml;r investigative Journalisten) teils auch von
							lebenswichtiger Bedeutung sein kann, werden die wenigsten Teilnehmer einen Key signieren, dessen Eigent&uuml;er sie nicht kennen.
							Anfragen per E-Mail sind daher meist nutzlos. Eine gute Grundlage f&uuml;r eine Signing Policy bilden zum Beispiel
							<ul>
								<li>Eine f&auml;lschungssichere Repr&auml;sentation des Schl&uuml;ssels</li>
								<li>Ein g&uuml;ltiger Identit&auml;tsbeweis (Personalausweis, etc)</li>
								<li>Pers&ouml;nliche &Uuml;bergabe</li>
							</ul>

							Einige Personen m&ouml;chten selbst entscheiden, welche Signaturen f&uuml;r ihren Schl&uuml;ssel sie ver&ouml;ffentlichen m&ouml;chten.
							Aus H&ouml;flichtkeit stellt man neue Signaturen den Schl&uuml;sselinhabern daher privat zur Verf&uuml;gung, statt sie ungefragt auf
							einem Keyserver zu ver&ouml;ffentlichen.

							<p>
								Eine gute Vorlage f&uuml;r eine Papier-Repr&auml;sentation eines eigenen Schl&uuml;ssels erh&auml;lt man beispielsweise durch das
								Tool <a href="https://github.com/rogers0/pgp-tools/blob/master/gpg-key2ps/gpg-key2ps"><code>gpg-key2ps</code></a>. Dabei sollte man
								aber stets darauf achten, diese Zettel nicht aus den Augen zu lassen - jemand k&ouml;nnte sie gegen welche mit einem gef&auml;lschten
								Key austauschen.
							</p>

							<h3>Signaturen abholen &amp; anzeigen</h3>
							Sollte jemand unseren Key signiert haben und die resultierende Signatur direkt auf einem Keyserver ver&ouml;ffentlich haben, k&ouml;nnen
							wir mit dem Befehl<br/>
							<code>
								user@box:~$ gpg --keyserver &lt;server&gt; --recv-keys &lt;identifier&gt;
							</code>
							<br/>
							den aktuellen Status unseres Keys von einem Keyserver abholen. Die Keyserver synchronisieren sich untereinander mit ein wenig Versatz, es kann
							also ein bisschen dauern bis die Signaturen auf unserem Lieblingskeyserver verf&uuml;gbar sind. Mit diesem Befehl k&ouml;nnen wir auch beliebige
							Keys von anderen Personen (bspw. Personen deren Key wir selbst signieren wollen) von den Servern abrufen. Diese &ouml;ffentlichen Schl&uuml;ssel
							werden dann in unseren lokalen Keyring kopiert und sind dort auch offline verf&uuml;gbar. Eine gute &Uuml;bersicht &uuml;ber aktive
							Keyserver findet sich bei <a href="https://sks-keyservers.net/">sks-keyservers</a>.
							
							<p>
								Manche Key-Inhaber m&ouml;chten ihre Schl&uuml;ssel aus diversen Gr&uuml;nden nicht auf Keyservern ver&ouml;ffentlichen, sondern
								versenden bspw. auf Anfrage ihre Schl&uuml;ssel als einzelne Dateien. Um diese Dateien zu importieren, verwenden wir den folgenden
								Befehl:<br />
								<code>
									user@box:~$ gpg --import &lt;datei.gpg&gt;
								</code>
								<br/>
								M&ouml;glicherweise ist die Datei verschl&uuml;sselt. Sollte dies der Fall sein m&uuml;ssen wir sie nat&uuml;rlich
								vorher entschl&uuml;sseln.
							</p>

							Die aktuell in unserem Keyring vorhandenen Schl&uuml;ssel werden mit folgendem Befehl angezeigt:<br/>
							<code>
								user@box:~$ gpg --list-keys
							</code>
							<br/>
							Analog lassen sich mit folgendem Befehl alle Signaturen an bestimmten Schl&uuml;sseln anzeigen:<br/>
							<code>
								user@box:~$ gpg --list-sigs &lt;identifier&gt;
							</code>
							<br/>

							<h3>Wie signiere ich einen Schl&uuml;ssel</h3>
							Prinzipiell signiert man beim Web of Trust eigentlich keine ganzen Schl&uuml;ssel (wohl aber <em>mit</em> einem Schl&uuml;ssel), sondern
							einzelne UIDs. Dabei existieren verschiedene &quot;Vertrauensgrade&quot;, welche optional verwendet werden k&ouml;nnen um bspw. die
							Sorgfalt der Verifikation zu zeigen. Die individuelle Bedeutung der Levels wird oft in der Signing Policy genauer beschrieben, die
							Beispielangaben durch GPG sind:
							<ul>
								<li>
									<strong>Level 0</strong>
									Keine Aussage. Dies ist der Standard wenn die Angabe von Vertrauensgraden nicht aktiviert ist.
								</li>
								<li>
									<strong>Level 1</strong>
									Keine Identit&auml;tspr&uuml;fung vorgenommen, aber wir glauben dass der Key dem Benutzer geh&ouml;rt.
									Kann beispielsweise f&uuml;r pseudonyme Keys verwendet werden.
								</li>
								<li>
									<strong>Level 2</strong>
									Grundlegende Identit&auml;ts&uuml;berpr&uuml;fung, bspw durch Vergleich des Fotos einer UID und Verifikation
									des Key-Fingerprints.
								</li>
								<li>
									<strong>Level 3</strong>
									Intensive Identit&auml;ts&uuml;berpr&uuml;fung, bspw durch pers&ouml;nliche Verifikation mit Ausweisdokumenten,
									etc.
								</li>
							</ul>

							Um einen Schl&uuml;ssel zu signieren, m&uuml;ssen wir ihn erst einmal, wie oben beschrieben, importieren (bspw von einem Keyserver oder
							aus einer Datei). Signiert wird immer mit dem private-Teil des Master-Keys, also ben&ouml;tigen wir diesen auf der Maschine, auf der wir
							die Signatur machen wollen.

							<p>
								Um nun die eigentliche Signatur vorzunehmen, starten wir die bearbeitung des zu signierenden Keys mit<br/>
								<code>
									user@box:~$ gpg --ask-cert-level --edit-key &lt;identifier&gt;
								</code>
								<br/>
								Die Option <code>--ask-cert-level</code> aktiviert dabei die detaillierte Abfrage des Vertrauensgrades.
								Danach selektieren wir die UID, welche wir signieren wollen und starten den Signatur-Assistenten mit<br/>
								<code>
									gpg&gt; uid &lt;nummer&gt;<br/>
									gpg&gt; sign
								</code>
								<br/>
								Nachdem der Assistent seine Abfragen beendet hat, kann man den Prozess f&uuml;r andere UIDs wiederholen, oder
								den Key mit der neuen Signatur mittels <code>save</code> in den lokalen Keyring speichern.
							</p>

							<h3>Schl&uuml;ssel und Signaturen ver&ouml;ffentlichen</h3>
							Um die Informationen und Signaturen aus dem lokalen Keyring an einen Keyserver zu &uuml;bertragen, wird folgender Befehl verwendet:<br/>
							<code>
								user@box:~$ gpg --keyserver &lt;keyserver&gt; --send-keys &lt;identifier&gt;
							</code>
							<br/>
							Es ist dabei nicht n&ouml;tig, den Key an mehrere Keyserver zu &uuml;bertragen, da diese sich untereinander synchronisieren.
							Aus H&ouml;flichkeit sollte darauf geachtet werden, dass nicht jeder begeistert ist, ungefragt neue Signaturen an seinem Key auf
							den Keyservern zu finden. Prinzipiell ist ein gutes vorgehen, neue Signaturen an den Keys anderer einzeln zu exportieren und diese ihnen dann,
							sinnvollerweise in verschl&uuml;sselter Form, zukommen zu lassen. Dies l&auml;sst ihnen die Option, selbst zu entscheiden welche Signaturen
							sie ver&ouml;ffentlichen. Ausserdem ist das hochladen der Signaturen dann ein weiterer Beweis daf&uuml;r, dass der Empf&auml;nger diesen Key
							und die dazugeh&ouml;rigen UIDs auch kontrolliert und abruft.

							<p>
								Der Prozess, eine einzelne Signatur zu exportieren, wird bei GPG leider sehr erschwert. Prinzipiell muessen daf&uuml;r folgende
								Schritte durchgef&uuml;hrt werden:
								<ol>
									<li>
										<strong>Importieren des Keys aus beliebiger Quelle</strong><br/>
										Dabei werden auch bisherige Signaturen am Key mit importiert.
									</li>
									<li>
										<strong>Minimieren des Keys</strong><br/>
										Hierbei werden die bisher existierenden Signaturen des Keys vom lokalen Keyring gel&ouml;scht.
										Dazu &ouml;ffnet man den zu bearbeitenden Schl&uuml;ssel mittels<br/>
										<code>
											user@box:~$ gpg --edit-key &lt;identifier&gt;
										</code>
										<br/>
										und gibt dann nacheinander die Befehle <code>minimize</code> und <code>save</code> ein.
									</li>
									<li>
										<strong>Signieren einer (oder aller) UIDs des Keys</strong><br/>
										Siehe vorherige Sektion.
									</li>
									<li>
										<strong>Exportieren des Keys</strong>
										Nach dem signieren kann der Schl&uuml;ssel aus dem lokalen Keyring mittels folgendem Befehl
										in eine Datei exportiert werden:<br/>
										<code>
											user@box:~$ gpg --export --armor &lt;identifier&gt; <strong>&gt;</strong> &lt;dateiname&gt;
										</code>
										<br/>
										Idealerweise verschl&uuml;sselt man diese Datei dann auch noch an den Eigent&uuml;mer des Keys
										mittels:<br/>
										<code>
											user@box:~$ gpg --armor --encrypt --recipient &lt;identifier&gt; &lt;dateiname&gt;
										</code>
										<br/>

										<p>
											Sollen die Signaturen einzelner UIDs in einzelne Dateien exportiert werden, muss
											nach dem Signieren einer UID und dem Export dieser Signatur der Key nochmals
											minimiert (also die gerade gemachte Signatur entfernt) werden.
										</p>
									</li>
								</ol>
								Dieser Prozess kann durch automatisierte Tools vereinfacht werden, n&auml;heres dazu findet sich in einer sp&auml;teren Sektion.
							</p>

							<h3>Signaturen importieren</h3>
							Sollten wir von einem anderen Benutzer eine Email mit einer neuen Signatur f&uuml;r unseren Schl&uuml;ssel bekommen haben, k&ouml;nnen
							wir diese mit demselben Import-Befehl den wir f&uuml;r ganze Keys benutzen importieren:<br/>
							<code>
								user@box:~$ gpg --import &lt;datei.gpg&gt;
							</code>
							<br/>
							Dies liegt daran, dass jede Einzel-Signatur prinzipiell eine Kopie des &Ouml;ffentlichen Schl&uuml;ssels mit genau dieser einen
							Signatur ist. Beim importieren f&uuml;gt GPG dann die Information aus der Datei mit den im lokalen Keyring vorhandenen Signaturen
							zusammen. Dies geschieht allerdings erst einmal nur lokal, wir m&uuml;ssen die neue Signatur danach also noch wie in der vorherigen
							Sektion beschrieben ver&ouml;ffentlichen.

							<h3>Automatisierung</h3>
							Wie man merkt, sind die diversen Prozesse des Web of Trust eigentlich immer dieselbe Abfolge. Daher gibt es mehrere Tools, die diesen Prozess
							auf mehr oder weniger aufw&auml;ndige Weise automatisieren. F&uuml;r Personen, die Erfahrung mit der Administration von Linux-Systemen haben
							und bspw. einen lokalen Mailausgangsserver betreiben, bietet sich <a href="https://wiki.debian.org/caff">caff</a> an, welches die resultierenden
							Signaturen gleich verschl&uuml;sselt via Email an die Empf&auml;nger &uuml;bermittelt. Auf airgapped-Maschinen m&ouml;chte man nat&uuml;rlich
							m&ouml;glichst wenig externen Code ausf&uuml;hren, um die Angriffsfl&auml;che zu minimieren. Hier gibt es beispielsweise
							<a href="https://github.com/cbdevnet/signet">signet</a>, welches &auml;hnliche Funktionalit&auml;ten wie caff bietet, aber in bash geschrieben
							und auf Offline-Systeme ausgerichtet ist.
							<p>
							</p>
						</div>
					</div>

					<div>
						<h2>Was tun, wenn der Schl&uuml;ssel kompromittiert wurde?</h2>
						<div class="section-padding">
							Sollte einer der ger&auml;tespezifischen Schl&uuml;ssel kompromittiert
							werden (Malware auf dem Handy, etc) oder verloren gehen, so laden wir zuerst
							wieder unser gesichertes System und mounten das sichere Speichermedium.
							<br/>
							Dann f&uuml;hren wir nacheinander folgende Schritte aus:
							<ol>
								<li>
									GNUPGHOME wieder auf das &quot;sichere&quot; GPG-Verzeichnis setzen.<br/>
									<code>user@box:~$ export GNUPGHOME=/media/meinSicheresMedium/gpg_home</code>	
								</li>
								<li>
									Schl&uuml;ssel bearbeiten.<br/>
									<code>user@box:~$ gpg --edit-key &lt;identifier&gt;</code>	
								</li>
								<li>
									Mit <br/><code>gpg&gt; key &lt;keyindex&gt;</code>
							       		<br/>
									die Subkeys ausw&auml;hlen,
									die revoked werden sollen. <code>keyindex</code> ist dabei der Index des 
									Unterschl&uuml;ssels, beginnend bei 1. Ein <code>key</code>-Befehl
									selektiert einen Schl&uuml;ssel (bezeichnet durch <code>sub*</code>),
									ein weiterer deselektiert ihn.
								</li>
								<li>
									<code>gpg&gt; revkey</code><br/>
									startet einen Assistenten, der einen Grund f&uuml;r den R&uuml;ckruf
									sowie die Passphrase abfragt.
								</li>
								<li>
									<code>gpg&gt; save</code><br/>
									speichert unsere &Auml;nderungen.
								</li>
								<li>
									Wir exportieren jetzt noch unseren &ouml;ffentlichen Schl&uuml;ssel neu,
									um die Ver&auml;nderung bekannt machen zu k&ouml;nnen.<br/>
									<code>user@box:~$ gpg --export --armor --no-emit-version &gt;identifier&lt; > /media/unsichererTeil/mein-key.asc</code><br/>
								</li>
								<li>
									Jetzt k&ouml;nnen wir den &ouml;ffentlichen Schl&uuml;ssel auf einer
									&quot;unsicheren&quot; Maschine wieder importieren und an die Keyserver senden.<br/>
									<code>
										user@box:~$ gpg --import /media/unsichererTeil/mein-key.asc<br/>
										user@box:~$ gpg --send-keys &lt;identifier&gt;
									</code>
								</li>
							</ol>
							Um neue Subkeys hinzuzuf&uuml;gen, k&ouml;nnen wir der obigen Anleitung zum
							generieren des Keypairs folgen und dabei die Schritte 2 und 3 auslassen.
							<p>
								Sollte dagegen das Master-Keypair verloren gegangen sein oder
								uns versehentlich in irgendwelche unsicheren Medien gekommen sein,
								wird es Zeit, das Revocation Certificate abzustauben.
								Wenn wir die damals erzeugte Datei noch verf&uuml;gbar haben,
								ist der Schritt recht einfach:<br/>
								<code>user@box:~$ gpg --import /media/meinSicheresMedium/master-pair.revcert</code><br/>
								Sollte dies nicht mehr der Fall sein, m&uuml;ssen wir die ausgedruckte
								Version rauskramen, abtippen und dann genauso importieren.
								Der Import des Revocation Certificates markiert das komplette Keypair als revoked. 
								Um das nun auch noch der Welt mitzuteilen, sollten wir die Keyserver von der 
								Ver&auml;nderung in Kenntnis setzen:<br/>
								<code>user@box:~$ gpg --send-keys &lt;identifier&gt;</code><br/>
								Mit dem n&auml;chsten Update unseres Keys aus den Keyservern sind damit
								die Benutzer in Kenntnis gesetzt, dass der Key zur&uuml;ckgerufen wurde.
								Jetzt schnell ein neues Keypair erzeugen! ;)
							</p>
						</div>
					</div>
					
					<div>
						<h2>Weiterf&uuml;hrendes &amp; Links</h2>
						<div class="section-padding">
							Sollte euch eines der genannten Projekte sehr gut gefallen,
							w&uuml;rden sie sich alle &uuml;ber Spenden (ob nun Geld oder
							Manpower beim Bugs reporten, Bugs fixen oder User supporten) 
							oder Lob freuen! Denkt dran, nur weil Software kostenlos ist,
							ist sie noch lange nicht wertlos!
							<ul>
								<li>
									<a href="https://www.gnupg.org/documentation/bts.html">GnuPG Bug Tracking System</a>
								</li>
								<li>
									<a href="https://www.gnupg.org/donate/index.html">GnuPG Spenden-Informationen</a>
								</li>
								<li>
									<a href="http://www.kde.org/community/donations/index.php#money">Kleopatra/KDE Spenden-Informationen</a>
								</li>
								<li>
									<a href="https://tails.boum.org/contribute/index.en.html">Tails contribution information</a>
								</li>
								<li>
									<a href="http://grml.github.io/">grml contribution information</a>
								</li>
							</ul>
							Die Informationen in diesem Dokument wurden zum grossen Teil aus
							dem Kopf geschrieben - unterst&uuml;tzt durch die Dokumentationen
							der verschiedenen Projekte und einige Blogeintr&auml;ge und Mailinglisten-Posts,
							f&uuml;r die wir den Autoren sehr dankbar sind:
							<ul>
								<li>
									<a href="https://www.gnupg.org/documentation/index.html">GnuPG Dokumentation</a>
								</li>
								<li>
									<a href="http://lists.gnupg.org/pipermail/gnupg-users/2002-August/014780.html">[gnupg-users] using various subkeys</a>
								</li>
								<li>
									<a href="https://alexcabal.com/creating-the-perfect-gpg-keypair/">Alex Cabal: Creating the perfect GPG Keypair</a>
								</li>
								<li>
									<a href="http://www.void.gr/kargig/blog/2013/12/02/creating-a-new-gpg-key-with-subkeys/">Into.the.Void: Creating a new GPG key with subkeys</a>
								</li>
								<li>
									<a href="https://wiki.debian.org/Subkeys">Debian Wiki: GPG Subkeys</a>
								</li>
								<li>
									<a href="https://gitlab.com/cryptsetup/cryptsetup/wikis/FrequentlyAskedQuestions#2-setup">Die LUKS-FAQ zum erstellen eines verschl&uuml;sselten Speichermediums</a>
								</li>
							</ul>
						</div>
					</div>
				</div>
				
				<div id="content-foot">
					<a href="../">#kitinfo Sharingparty Portal</a> - Crypto HowTo
				</div>
			</div>
			<div style="text-align:right;padding:0.3em 1em 0 1em;">
				<a href="http://www.kopimi.com/kopimi/"><img src="../static/kopimi.png" alt="kopimi" /></a>
				<a href="http://wtfpl.net/"><img src="../static/wtfpl.png" alt="wtfpl" /></a>
			</div>
		</div>
	</body>
</html>
